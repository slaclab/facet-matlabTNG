classdef F2_LEMApp < handle & matlab.mixin.Copyable
  %F2_LEMAPP FACET-II Linac Energy Management application
  events
    PVUpdated
  end
  properties(SetObservable)
    blen(1,4) = [735 735 438 90] % rms Bunch length in L0, L1, L2 & L3 (um)
    bq(1,4) = [2 2 2 2] % Bunch charge in L0, L1, L2 & L3 (nC)
    linacsel(1,5) logical = [true true true true true] % use: L0, L1, L2, L3, S20
    RescaleWithModel logical = false % Set true to rescale based on model rather than extant magnet settings
  end
  properties(SetAccess=private)
    Eref(1,5) = [0.005 0.135 0.335 4.5 10] % reference energies at entrance to regionNames (GeV)
    fref(1,4) = [1 1 1 1] % Reference fudge factors
    fact(1,4) % extant fudge factors
    regionwakeloss(1,4) = [0 0 0 0] % Total wakefield energy loss per region (MeV)
    klyswakeloss(8,10) = zeros(10,8) % Wakeloss for each station (MeV)
    pvlist
    pvs
    aobj F2_LEM
    Klys F2_klys
    Mags F2_mags
    LM LucretiaModel
    wakedat
    RefTwiss % Twiss parameters with scaled magnets
    Pref
  end
  properties(Access=private)
    UndoSettings
  end
  properties(Constant)
    version single = 1
    regionNames = ["L0" "L1" "L2" "L3" "S20"] ;
  end
  methods
    function obj = F2_LEMApp(appobj)
      %F2_LEMAPP FACET-II Linac Energy Management application
      global BEAMLINE
      
      obj.message("Starting LEM Application...");
      
      % Store app object if given
      if exist('appobj','var')
        obj.aobj = appobj ;
      end
      
      % Generate PV links
      obj.message("Linking to EPICS PVs...");
      context = PV.Initialize(PVtype.EPICS) ;
      obj.pvlist = PV(context,'name',"Data",'pvame',"SIOC:SYS1:ML00:FWF09",'nmax',length(BEAMLINE)+4) ;
      pset(obj.pvlist,'debug',0) ;
      obj.pvs = struct(obj.pvlist) ;
      dat = caget(obj.pvs.Data) ; % Reference momenta of last LEM application and reference fudge factors
      obj.Pref = dat(1:end-4) ;
      obj.fref = dat(end-3:end) ;
      
      % Initialize extant property values
      obj.fact = obj.fref ;
      
      obj.message("Loading Model data and updating with live values...");
      % Load wakefield Eloss data
      ld = load("common/swakelossfit.mat");
      obj.wakedat.sz = ld.sz ; % rms bunch length (um)
      obj.wakedat.Eloss = ld.Eloss ; % energy loss / m / nC (GeV)
      
      % Instantiate and configure model, klystron & magnet objects
      obj.LM = LucretiaModel("common/FACET2e.mat") ;
      obj.Klys = F2_klys(obj.LM) ; % Constructs with update of live klystron data
      obj.Mags = F2_mags(obj.LM) ;
      obj.Mags.MagClasses = ["QUAD" "SEXT"] ;
      
      % Fetch all magnet data once
      obj.Mags.getB;
      
      % Load last reference energies and run LEM calculations
      for iele=1:length(BEAMLINE)
        BEAMLINE{iele}.P=obj.Pref(iele);
      end
      obj.UpdateEREF;
      obj.message("Initialization complete.");
    end
    function DoMagnetScale(obj)
      %DOMAGNETSCALE Write new scaled magnet strengths to control system
      global BEAMLINE
      if isprop(obj.aobj,'TabGroup')
        obj.aobj.TabGroup2.SelectedTab=obj.aobj.MessagesTab ;
      end
      if isempty(obj.Mags.BDES_cntrl) || isempty(obj.Mags.BDES)
        obj.message("!!!!!!! No magnet strengths read, push 'Read Data' button");
        return
      end
      if obj.RescaleWithModel
        obj.message("Scaling magnets from Design values to match current energy profile...");
      else
        obj.message("Scaling magnets from current values to match energy profile...");
      end
      obj.UndoSettings.BDES = obj.Mags.BDES ;
      obj.UndoSettings.BDES_cntrl = obj.Mags.BDES_cntrl ;
      obj.UndoSettings.Pref = obj.Pref ;
      msg = obj.Mags.SetBDES ;
      obj.Pref = arrayfun(@(x) BEAMLINE{x}.P,1:length(BEAMLINE));
      caput(obj.pvs.Data,[obj.Pref obj.fref]);
      if ~isempty(msg)
        obj.message(msg(:));
      end
      obj.UpdateModel;
      if isprop(obj.aobj,'TabGroup')
        obj.aobj.UndoButton.Enable = true ;
        obj.message("Done. Push 'Undo' to backout changes");
      else
        obj.message("Done.");
      end
    end
    function UndoMagnetScale(obj)
      if isprop(obj.aobj,'TabGroup')
        obj.aobj.TabGroup2.SelectedTab=obj.aobj.MessagesTab ;
      end
      obj.message("Undoing last LEM operation, restoring Magnets...");
      if isempty(obj.UndoSettings)
        obj.message("No previous magnet setting data to undo, aborting.");
      else
        obj.Mags.BDES = obj.UndoSettings.BDES_cntrl ;
        msg = obj.Mags.SetBDES ;
        if ~isempty(msg)
          obj.message(msg(:));
        end
        obj.Mags.BDES = obj.UndoSettings.BDES ;
        obj.Pref = obj.UndoSettings.Pref ;
        caput(obj.pvs.Data,obj.Pref);
        obj.UndoSettings = [] ;
        obj.UpdateModel ;
      end
      obj.message("Done.");
      if isprop(obj.aobj,'TabGroup')
        obj.aobj.UndoButton.Enable = false ;
      end
    end
    function set.RescaleWithModel(obj,val)
      val=logical(val);
      if val~=obj.RescaleWithModel
        obj.RescaleWithModel=val;
        if ~isempty(obj.Mags.BDES_cntrl)
          obj.UpdateEREF;
        end
      end
    end
    function message(obj,txt)
      fprintf('%s:\n',datestr(now));
      fprintf('%s\n',txt(:));
      if ~isempty(obj.aobj)
        mtxt = string(obj.aobj.TextArea.Value) ;
        mtxt(end+1) = string(datestr(now));
        mtxt = mtxt(string(txt(:))) ;
        obj.aobj.TextArea.Value = [ string(obj.aobj.TextArea.Value); mtxt(string(txt(:))) ] ;
        scroll(obj.aobj.TextArea,'bottom');
        drawnow;
      end
    end
    function UpdateModel(obj)
      %UPDATEMODEL Get control system values and put in model
      obj.message("Getting new data from controls and updating model...");
      try
        obj.Mags.getB;
      catch ME
        obj.message("!!!!!! Error Getting magnet data:");
        obj.message(ME.message);
        return
      end
      try
        obj.Klys.UpdateData;
      catch ME
        obj.message("!!!!!! Error Getting klystron data:");
        obj.message(ME.message);
        return
      end
      try
        obj.UpdateEREF;
      catch ME
        obj.message("!!!!!! Error Updating Model:");
        obj.message(ME.message);
        return
      end
      obj.message("Done.");
    end
    function UpdateEREF(obj)
      global BEAMLINE KLYSTRON
      %UPDATEEREF Update Eref property based on live Klystron values, update model and scale model magnets
      secid = obj.LM.ModelRegionID([1 3 5 7 11],2) ;
      obj.LM.SetKlystronData(obj);
      eref=obj.Eref;
      wakeloss=zeros(1,4);
      if obj.RescaleWithModel % Load design model instead of live model if request to scale wrt Design
        obj.Mags.LM.SetDesignModel;
      else % Scale with respect to momentum reference (last LEM action)
        if length(obj.Pref) ~= length(BEAMLINE)
          obj.message("!!!!!!!! Length mismatch between reference momentum profile and model, aborting update.");
          return
        end
        for iele=1:length(BEAMLINE)
          BEAMLINE{iele}.P=obj.Pref(iele);
        end
      end
      for isec=1:length(secid)-1 % L0, L1, L2, L3&S20
        % Set Kloss data in LCAV's using lookup table in wakedat property
        % - Eloss is GeV / m / nC -> convert to V/C/m for Lucretia Kloss property
        kl = interp1(obj.wakedat.sz,obj.wakedat.Eloss,obj.blen(isec))*1e18 ;
        for ikly=findcells(BEAMLINE,'Class','LCAV',secid(isec),secid(isec+1)) % L0
          if BEAMLINE{ikly}.Freq==2856
            BEAMLINE{ikly}.Kloss = kl ;
            wakeloss(isec)=wakeloss(isec)+kl*BEAMLINE{ikly}.L*obj.bq(isec)*1e-15 ; % MeV
          end
        end
        % Set energy profile and scale Model magnets
        UpdateMomentumProfile(secid(isec),secid(isec+1),obj.bq(isec).*1e-9,obj.Eref(isec),1) ;
        eref(isec+1) = BEAMLINE{secid(isec+1)}.P ;
      end
      obj.klyswakeloss=zeros(8,10);
      for isec=1:10
        for ikly=1:8
          if ~obj.Klys.KlysInUse(ikly,isec)
            continue
          end
          klyno = obj.LM.ModelKlysID(isec,ikly) ;
          secid = obj.Klys.KlysSectorMap(ikly,isec) ;
          obj.klyswakeloss(iklys,isec) = sum(arrayfun(@(x) BEAMLINE{x}.Kloss,KLYSTRON(klyno).Element)).*obj.bq(secid)*1e-15 ; % MeV
        end
      end
      obj.Eref=eref;
      obj.regionwakeloss=wakeloss;
      % Store required BDES values in controls object and get reference Twiss values for scaled lattice
      obj.Mags.BDES = obj.Mags.LM.ModelBDES ;
      obj.Mags.LM.StoreRefTwiss;
      % Put back design or current control BDES values back into model for comparisons
      if obj.RescaleWithModel
        obj.Mags.LM.SetDesignModel("PS");
      else
        obj.Mags.LM.ModelBDES = obj.Mags.BDES_cntrl ;
      end
    end
    function set.bq(obj,Q)
      obj.bq = Q ;
      obj.LM.Initial.Q = Q(1)*1e-9 ;
      obj.UpdateEREF; % need to update wakeloss entries
    end
    function set.blen(obj,blen)
      obj.blen = blen ;
      obj.LM.Initial.sigz = blen*1e-6 ; 
      obj.UpdateEREF; % need to update wakeloss entries
    end
    function set.linacsel(obj,sel)
      obj.linacsel=sel;
      obj.Mags.UseSector=sel;
      obj.UpdateGUI;
    end
    function UpdateGUI(obj)
      %UPDATEGUI Update visible GUI tab info
      global BEAMLINE
      if ~isprop(obj.aobj,'TabGroup') % do nothing if no valid GUI present
        return
      end
      app=obj.aobj;
      switch app.TagGroup.SelectedTab % left side Tab group
        case app.EREFSTab
          app.GunEref.Value = obj.Eref(1) ;
          app.DL1Eref.Value = obj.Eref(2) ;
          app.BC11Eref.Value = obj.Eref(3) ;
          app.BC14Eref.Value = obj.Eref(4) ;
          app.BC20Eref.Value = obj.Eref(5) ;
          app.EditField.Value = obj.fact(1) ;
          if abs(obj.fref(1)-obj.fact(1))>0.0001; app.EditField.FontColor='red'; else; app.EditField.FontColor='black'; end
          app.EditField_2.Value = obj.fref(1) ;
          app.EditField_3.Value = obj.fact(2) ;
          if abs(obj.fref(2)-obj.fact(2))>0.0001; app.EditField_3.FontColor='red'; else; app.EditField_3.FontColor='black'; end
          app.EditField_4.Value = obj.fref(2) ;
          app.EditField_5.Value = obj.fact(3) ;
          if abs(obj.fref(3)-obj.fact(3))>0.0001; app.EditField_5.FontColor='red'; else; app.EditField_5.FontColor='black'; end
          app.EditField_6.Value = obj.fref(3) ;
          app.EditField_7.Value = obj.fact(4) ;
          if abs(obj.fref(4)-obj.fact(4))>0.0001; app.EditField_7.FontColor='red'; else; app.EditField_7.FontColor='black'; end
          app.EditField_8.Value = obj.fref(4) ;
        case app.WakesTab
          app.L0EditField.Value = obj.bq(1) ;
          app.L1EditField.Value = obj.bq(2) ;
          app.L2EditField.Value = obj.bq(3) ;
          app.L3EditField.Value = obj.bq(4) ;
          app.EditField_175.Value = obj.blen(1) ;
          app.EditField_176.Value = obj.blen(2) ;
          app.EditField_177.Value = obj.blen(3) ;
          app.EditField_178.Value = obj.blen(4) ;
          app.EditField_179.Value = obj.regionwakeloss(1) ;
          app.EditField_180.Value = obj.regionwakeloss(2) ;
          app.EditField_181.Value = obj.regionwakeloss(3) ;
          app.EditField_182.Value = obj.regionwakeloss(4) ;
        case app.RFTab
          app.EditField_169.Value = obj.Klys.SectorPhase(2) ;
          app.EditField_170.Value = obj.Klys.SectorPhase(3) ;
          app.EditField_171.Value = obj.Klys.SectorPhase(4) ;
          app.EditField_172.Value = obj.Eref(3)-obj.Eref(2) ;
          app.EditField_173.Value = obj.Eref(4)-obj.Eref(3) ;
          app.EditField_174.Value = obj.Eref(5)-obj.Eref(4) ;
          app.EditField_183.Value = (obj.Eref(3)-obj.Eref(2)) * sind(obj.Klys.SectorPhase(2)) ;
          app.EditField_184.Value = (obj.Eref(4)-obj.Eref(3)) * sind(obj.Klys.SectorPhase(3)) ;
          app.EditField_185.Value = (obj.Eref(5)-obj.Eref(4)) * sind(obj.Klys.SectorPhase(4)) ;
        case app.MagnetsTab_2
          app.UseExtantStrengthsButton.Value = ~obj.RescaleWithModel ;
          app.UseModelStrengthsButton.Value = obj.RescaleWithModel ;
      end
      switch app.TagGroup2.SelectedTab % right side Tab group
        case app.EProfileTab
          h=app.UIAxes;
          id=find(obj.GetRegionID);
          z_mags=arrayfun(@(x) BEAMLINE{x}.Coordi(3),id);
          p=arrayfun(@(x) BEAMLINE{x}.P,id);
          p_ref=obj.Pref(id);
          dE = obj.Klys.KlysAmpl(obj.Klys.KlysInUse).*cosd(obj.Klys.KlysPhase(obj.Klys.KlysInUse)) - ...
            obj.klyswakeloss(obj.Klys.KlysInUse) ;
          dE_z = obj.LM.ModelKlysZ(obj.Klys.KlysInUse) ;
          yyaxis(h,'left');
          stem(dE_z,dE);
          xlabel('Z [m]'); ylabel('Egain [MeV]');
          yyaxis(h,'right');
          plot(z_mags,p,z_mags,p_ref);
          ylabel('E [GeV]');
          AddMagnetPlotZ(id(1),id(end),h);
        case app.KlysEgainTab
          for ikly=1:8
            for isec=1:10
              if obj.Klys.KlysInUse(ikly,isec)
                egain = num2str(obj.Klys.KlysAmpl(ikly,isec)*cosd(obj.Klys.KlysPhase(ikly,isec)) - obj.klyswakeloss(ikly,isec),4) ;
              else
                egain="---";
              end
              app.(sprintf('EditField_%d',(ikly-1)*10+isec+8)).Value=egain;
            end
          end
        case app.KlysPhaseTab
          for ikly=1:8
            for isec=1:10
              if obj.Klys.KlysInUse(ikly,isec)
                pha = obj.Klys.KlysPhase(ikly,isec) ;
              else
                pha="---";
              end
              app.(sprintf('EditField_%d',(ikly-1)*10+isec+88)).Value=pha;
            end
          end
        case app.MagnetsTab
          h=app.UIAxes2;
          yyaxis(h,'left');
          z_mags=obj.Mags.LM.ModelBDES_Z;
          stem(z_mags,obj.Mags.BDES_cntrl,z_mags(obj.Mags.BDES_err),obj.Mags.BDES(obj.Mags.BDES_err));
          xlabel('Z [m]'); ylabel('BDES [kG]');
          yyaxis(h,'right');
          z=arrayfun(@(x) BEAMLINE{x}.Coordi(3),1:length(BEAMLINE));
          if obj.RescaleWithModel
            bmag=obj.Mags.LM.GetBMAG("Design") ;
          else
            bmag=obj.Mags.LM.GetBMAG("Ref") ;
          end
          iz=z==z_mags;
          plot(z(iz),bmag(iz,1),z(iz),bmag(iz,2));
          ylabel('BMAG_{x,y}');
          legend
        case app.MessagesTab
      end
    end
    function inds = GetRegionID(obj)
      %GETREGIONID Return BEAMLINE indices for selected regions
      % Return logical vector of length BEAMLINE
      global BEAMLINE
      inds=true(1,length(BEAMLINE));
      if ~obj.linacsel(1)
        inds(obj.LM.ModelRegionID(1,1):obj.LM.ModelRegionID(3,2))=false;
      end
      if ~obj.linacsel(2)
        inds(obj.LM.ModelRegionID(4,1):obj.LM.ModelRegionID(5,2))=false;
      end
      if ~obj.linacsel(3)
        inds(obj.LM.ModelRegionID(6,1):obj.LM.ModelRegionID(7,2))=false;
      end
      if ~obj.linacsel(4)
        inds(obj.LM.ModelRegionID(8,1):obj.LM.ModelRegionID(8,2))=false;
      end
      if ~obj.linacsel(5)
        inds(obj.LM.ModelRegionID(9,1):obj.LM.ModelRegionID(end,2))=false;
      end
    end
    function SetGunEref(obj,eref)
      %SETGUNEREF Change the initial reference energy for the lattice (GeV)
      % Changes Linac reference energies
      obj.Eref = [ eref obj.Eref(2:end)+(eref-obj.Eref(1)) ] ;
      obj.UpdateGUI;
    end
    function SetLinacEref(obj,eref)
      %SETLINACEREF Change the Linac reference energy (1x4) vector (GeV)
      % Changes extant fudge factors to match
      if length(eref)~=4
        error('4 element vector of energies (GeV) required');
      end
      obj.fact = obj.fact .* (eref-obj.Eref(2:end))./obj.Eref(2:end) ;
      obj.Eref(2:end) = eref ;
      obj.UpdateGUI;
    end
    function SetFREF(obj,fref)
      %SETFREF Store extant (or user supplied) fudge factor references and write to PV
      if exist('fref','var')
        if length(fref)~=4
          error('Need to supply 4 element vector');
        end
        obj.fref=fref;
      else
        obj.fref=obj.fact;
      end
      caput(obj.pvs.Data,[obj.Pref obj.fref]);
    end
    function SetPREF(obj)
      % SetPREF Store current BEAMLINE momentum profile into EPICS and Pref property
      global BEAMLINE
      if isempty(BEAMLINE)
        error('No model loaded into memory');
      end
      pref=arrayfun(@(x) BEAMLINE{x}.P,1:length(BEAMLINE));
      obj.Pref=pref;
      caput(obj.pvs.Data,[pref obj.fref]);
    end
    function SaveModel(obj,dir,fname)
      global BEAMLINE PS KLYSTRON
      LEM = obj ;
      save(fullfile(dir,sprintf('%s.mat',regexprep(fname,'\.mat$',''))),'BEAMLINE','PS','KLYSTRON','LEM');
    end
    function LoadModel(obj,dir,fname)
      global BEAMLINE PS KLYSTRON
      ld=load(fullfile(dir,sprintf('%s.mat',regexprep(fname,'\.mat$',''))),'BEAMLINE','PS','KLYSTRON','LEM');
      if ~isfield(ld,'LEM') || ~isfield(ld,'BEAMLINE') || length(ld.BEAMLINE)~=length(BEAMLINE)
        error('Model in file not compatible with Model in memory');
      end
      BEAMLINE=ld.BEAMLINE; PS=ld.PS; KLYSTRON=ld.KLYSTRON; obj.Pref=ld.LEM.Pref; obj.fact=ld.LEM.fact; obj.fref=ld.LEM.fref;
    end
    function SaveData
  end
end